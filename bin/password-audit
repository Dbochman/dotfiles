#!/usr/bin/env python3
"""
password-audit â€” Audit 1Password logins for stale, weak, reused, and breached passwords.

Uses the 1Password CLI (op) and the Have I Been Pwned k-anonymity API.
Assumes op is already authenticated (biometric/desktop app unlock).

Usage:
    password-audit                      # all vaults, markdown to stdout
    password-audit --vault Private      # single vault
    password-audit --output report.md   # write to file
    password-audit --skip-hibp          # skip breach checks
    password-audit --age-warn 180 --age-stale 365  # custom thresholds (days)
"""

import argparse
import hashlib
import json
import math
import ssl
import subprocess
import sys
import time
import urllib.request
from collections import defaultdict
from datetime import datetime, timezone

try:
    import certifi
    _SSL_CONTEXT = ssl.create_default_context(cafile=certifi.where())
except ImportError:
    _SSL_CONTEXT = ssl.create_default_context()


def run_op(args: list[str]) -> str:
    """Run an op CLI command and return stdout."""
    result = subprocess.run(
        ["op"] + args, capture_output=True, text=True, timeout=30
    )
    if result.returncode != 0:
        raise RuntimeError(f"op {' '.join(args)}: {result.stderr.strip()}")
    return result.stdout


def get_all_logins(vault: str | None = None) -> list[dict]:
    """Fetch all login items from 1Password."""
    cmd = ["item", "list", "--categories", "Login", "--format=json"]
    if vault:
        cmd += ["--vault", vault]
    return json.loads(run_op(cmd))


def get_item_password(item_id: str) -> str | None:
    """Extract the password field from an item. Returns None if missing/empty."""
    try:
        raw = run_op(["item", "get", item_id, "--fields", "label=password", "--format=json"])
        data = json.loads(raw)
        value = data.get("value", "")
        return value if value else None
    except Exception:
        # Some items have non-standard password field labels
        try:
            raw = run_op(["item", "get", item_id, "--format=json"])
            item = json.loads(raw)
            for field in item.get("fields", []):
                if field.get("purpose") == "PASSWORD" and field.get("value"):
                    return field["value"]
        except Exception:
            pass
    return None


def password_entropy(pw: str) -> float:
    """Estimate password entropy in bits."""
    charset_size = 0
    if any(c.islower() for c in pw):
        charset_size += 26
    if any(c.isupper() for c in pw):
        charset_size += 26
    if any(c.isdigit() for c in pw):
        charset_size += 10
    if any(not c.isalnum() for c in pw):
        charset_size += 32
    if charset_size == 0:
        return 0
    return len(pw) * math.log2(charset_size)


def score_strength(pw: str) -> tuple[str, float]:
    """Rate password strength. Returns (rating, entropy)."""
    entropy = password_entropy(pw)
    if len(pw) < 8 or entropy < 28:
        return "weak", entropy
    if len(pw) < 12 or entropy < 45:
        return "fair", entropy
    if entropy < 60:
        return "good", entropy
    return "strong", entropy


def check_hibp(pw: str) -> int:
    """Check if password appears in Have I Been Pwned breaches.
    Uses k-anonymity: only sends first 5 chars of SHA-1 hash.
    Returns the number of times the password was seen, or 0.
    """
    sha1 = hashlib.sha1(pw.encode("utf-8")).hexdigest().upper()
    prefix, suffix = sha1[:5], sha1[5:]
    url = f"https://api.pwnedpasswords.com/range/{prefix}"
    req = urllib.request.Request(url, headers={"User-Agent": "password-audit/1.0"})
    try:
        with urllib.request.urlopen(req, timeout=10, context=_SSL_CONTEXT) as resp:
            for line in resp.read().decode().splitlines():
                hash_suffix, count = line.split(":")
                if hash_suffix == suffix:
                    return int(count)
    except Exception:
        return -1  # indicate check failed
    return 0


def age_days(date_str: str) -> int:
    """Days since an ISO datetime string."""
    dt = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
    return (datetime.now(timezone.utc) - dt).days


def classify_risk(
    breached: int, reused: bool, strength: str, age: int,
    age_warn: int, age_stale: int
) -> str:
    """Classify into Critical / High / Medium / Low."""
    if breached > 0:
        return "Critical"
    if reused:
        return "Critical"
    if strength == "weak":
        return "High"
    if strength == "fair":
        return "High"
    if age >= age_stale:
        return "Medium"
    if age >= age_warn:
        return "Medium"
    return "Low"


def render_markdown(results: list[dict], skip_hibp: bool) -> str:
    """Render the audit results as a markdown report."""
    lines = []
    lines.append("# 1Password Security Audit Report")
    lines.append(f"**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    lines.append(f"**Items audited**: {len(results)}")
    lines.append("")

    # Summary counts
    tiers = defaultdict(list)
    for r in results:
        tiers[r["risk"]].append(r)

    lines.append("## Summary")
    lines.append("")
    lines.append("| Risk Level | Count |")
    lines.append("|------------|-------|")
    for tier in ["Critical", "High", "Medium", "Low"]:
        count = len(tiers.get(tier, []))
        lines.append(f"| {tier} | {count} |")
    lines.append("")

    # Reuse groups
    pw_hashes = defaultdict(list)
    for r in results:
        pw_hashes[r["pw_hash"]].append(r["title"])
    reuse_groups = {h: titles for h, titles in pw_hashes.items() if len(titles) > 1}
    if reuse_groups:
        lines.append("## Reused Passwords")
        lines.append("")
        lines.append(f"**{len(reuse_groups)} groups** of items share the same password:")
        lines.append("")
        for i, (_, titles) in enumerate(reuse_groups.items(), 1):
            lines.append(f"**Group {i}** ({len(titles)} items):")
            for t in sorted(titles):
                lines.append(f"- {t}")
            lines.append("")

    # Detail sections per tier
    for tier in ["Critical", "High", "Medium", "Low"]:
        items = tiers.get(tier, [])
        if not items:
            continue
        lines.append(f"## {tier} ({len(items)} items)")
        lines.append("")
        header = "| Title | Vault | Strength | Entropy | Age (days) |"
        separator = "|-------|-------|----------|---------|------------|"
        if not skip_hibp:
            header += " Breached |"
            separator += "----------|"
        header += " Reused | Reason |"
        separator += "--------|--------|"
        lines.append(header)
        lines.append(separator)
        for r in sorted(items, key=lambda x: (-x["age"], x["title"])):
            row = f"| {r['title']} | {r['vault']} | {r['strength']} | {r['entropy']:.0f} bits | {r['age']} |"
            if not skip_hibp:
                if r["breached"] > 0:
                    row += f" {r['breached']}x |"
                elif r["breached"] == -1:
                    row += " error |"
                else:
                    row += " no |"
            row += f" {'yes' if r['reused'] else 'no'} | {r['reason']} |"
            lines.append(row)
        lines.append("")

    # Rotation commands
    lines.append("## Rotation Commands")
    lines.append("")
    lines.append("To generate a new strong password for an item:")
    lines.append("```bash")
    lines.append("op item edit <ITEM_ID> --generate-password='32,letters,digits,symbols'")
    lines.append("```")
    lines.append("")
    lines.append("Or generate a password without saving:")
    lines.append("```bash")
    lines.append("op item get <ITEM_ID> --fields label=password  # see current")
    lines.append("op generate-password --length=32 --characters='letters,digits,symbols'  # preview new")
    lines.append("```")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Audit 1Password for stale/weak/reused/breached passwords")
    parser.add_argument("--vault", help="Only audit items in this vault")
    parser.add_argument("--output", "-o", help="Write report to file instead of stdout")
    parser.add_argument("--skip-hibp", action="store_true", help="Skip Have I Been Pwned breach checks")
    parser.add_argument("--age-warn", type=int, default=180, help="Days before password is 'aging' (default: 180)")
    parser.add_argument("--age-stale", type=int, default=365, help="Days before password is 'stale' (default: 365)")
    parser.add_argument("--json", action="store_true", help="Output raw JSON instead of markdown")
    args = parser.parse_args()

    # Fetch items
    print("Fetching login items...", file=sys.stderr)
    items = get_all_logins(args.vault)
    print(f"Found {len(items)} login items", file=sys.stderr)

    # Process each item
    results = []
    pw_seen = defaultdict(list)  # hash -> list of item titles

    for i, item in enumerate(items):
        title = item["title"]
        vault_name = item.get("vault", {}).get("name", "?")
        item_id = item["id"]
        updated = item.get("updated_at", item.get("created_at", ""))

        print(f"  [{i+1}/{len(items)}] {title}...", file=sys.stderr, end="", flush=True)

        pw = get_item_password(item_id)
        if not pw:
            print(" (no password, skipped)", file=sys.stderr)
            continue

        strength, entropy = score_strength(pw)
        age = age_days(updated) if updated else 0
        pw_hash = hashlib.sha256(pw.encode()).hexdigest()
        pw_seen[pw_hash].append(title)

        # HIBP check
        breached = 0
        if not args.skip_hibp:
            breached = check_hibp(pw)
            time.sleep(0.1)  # be polite to HIBP API

        print(f" strength={strength} age={age}d", file=sys.stderr)

        results.append({
            "title": title,
            "vault": vault_name,
            "item_id": item_id,
            "strength": strength,
            "entropy": entropy,
            "age": age,
            "breached": breached,
            "reused": False,  # will be set below
            "pw_hash": pw_hash,
            "reason": "",
        })

    # Mark reuse
    reused_hashes = {h for h, titles in pw_seen.items() if len(titles) > 1}
    for r in results:
        r["reused"] = r["pw_hash"] in reused_hashes

    # Classify risk and build reason
    for r in results:
        reasons = []
        if r["breached"] > 0:
            reasons.append(f"breached ({r['breached']}x)")
        if r["reused"]:
            reasons.append("reused")
        if r["strength"] in ("weak", "fair"):
            reasons.append(f"{r['strength']} password")
        if r["age"] >= args.age_stale:
            reasons.append(f"stale ({r['age']}d)")
        elif r["age"] >= args.age_warn:
            reasons.append(f"aging ({r['age']}d)")
        r["reason"] = ", ".join(reasons) if reasons else "ok"
        r["risk"] = classify_risk(
            r["breached"], r["reused"], r["strength"], r["age"],
            args.age_warn, args.age_stale
        )

    # Sort by risk
    risk_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3}
    results.sort(key=lambda r: (risk_order.get(r["risk"], 9), -r["age"], r["title"]))

    # Output
    if args.json:
        # Strip pw_hash from JSON output for safety
        safe = [{k: v for k, v in r.items() if k != "pw_hash"} for r in results]
        output = json.dumps(safe, indent=2)
    else:
        output = render_markdown(results, args.skip_hibp)

    if args.output:
        with open(args.output, "w") as f:
            f.write(output)
        print(f"\nReport written to {args.output}", file=sys.stderr)
    else:
        print(output)

    # Summary to stderr
    from collections import Counter
    counts = Counter(r["risk"] for r in results)
    print(f"\nDone. Critical: {counts.get('Critical', 0)}, High: {counts.get('High', 0)}, "
          f"Medium: {counts.get('Medium', 0)}, Low: {counts.get('Low', 0)}", file=sys.stderr)


if __name__ == "__main__":
    main()
