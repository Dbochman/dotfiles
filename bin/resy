#!/usr/bin/env python3
# resy — CLI wrapper for Resy restaurant reservation API
# Credentials stored in 1Password; tokens auto-refresh.

import sys
import os
import time
import json
import subprocess
import logging
import signal
from collections import deque
from pathlib import Path
from datetime import datetime

import warnings
warnings.filterwarnings("ignore", message="urllib3.*OpenSSL")

try:
    import requests
except ImportError:
    print("Error: 'requests' module not found. Install with: pip3 install requests", file=sys.stderr)
    sys.exit(1)

# ---------------------------------------------------------------------------
# Globals
# ---------------------------------------------------------------------------

CACHE_DIR = Path.home() / ".cache" / "openclaw-gateway"
LOG_DIR = Path.home() / ".openclaw" / "logs"
LOG_FILE = LOG_DIR / "resy.log"
BASE_URL = "https://api.resy.com"

TTL_LONG = 365 * 24 * 3600   # 1 year — api_key, email, password
TTL_SHORT = 12 * 3600        # 12 hours — auth_token, payment_id

# Set up logging
LOG_DIR.mkdir(parents=True, exist_ok=True)
logging.basicConfig(
    filename=str(LOG_FILE),
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
log = logging.getLogger("resy")

# Per-command result caps
MAX_SEARCH_RESULTS = 10
MAX_AVAILABILITY_SLOTS = 50

# Global flags
JSON_OUTPUT = False
DRY_RUN = False


# ---------------------------------------------------------------------------
# Log redaction — never log tokens, passwords, or API keys
# ---------------------------------------------------------------------------

_REDACT_PATTERNS = None

def _redact(text):
    """Redact sensitive values from log output."""
    global _REDACT_PATTERNS
    if _REDACT_PATTERNS is None:
        import re
        _REDACT_PATTERNS = [
            (re.compile(r'(api_key[=":]+\s*)"?[^"&\s,}]+"?'), r'\1"[REDACTED]"'),
            (re.compile(r'(auth.token[=":]+\s*)"?[^"&\s,}]+"?', re.IGNORECASE), r'\1"[REDACTED]"'),
            (re.compile(r'(password[=":]+\s*)"?[^"&\s,}]+"?', re.IGNORECASE), r'\1"[REDACTED]"'),
            (re.compile(r'(token[=":]+\s*)"?[A-Za-z0-9_\-]{20,}"?'), r'\1"[REDACTED]"'),
            (re.compile(r'(book_token[=":]+\s*)"?[^"&\s,}]+"?'), r'\1"[REDACTED]"'),
        ]
    for pattern, replacement in _REDACT_PATTERNS:
        text = pattern.sub(replacement, text)
    return text


# ---------------------------------------------------------------------------
# Rate Limiter
# ---------------------------------------------------------------------------

class RateLimiter:
    """Enforces min 2s between requests, max 30/minute."""

    def __init__(self, min_interval=2.0, max_per_minute=30):
        self.min_interval = min_interval
        self.max_per_minute = max_per_minute
        self.timestamps = deque()

    def wait(self):
        now = time.time()
        # Purge timestamps older than 60s
        while self.timestamps and now - self.timestamps[0] > 60:
            self.timestamps.popleft()
        # Enforce max per minute
        if len(self.timestamps) >= self.max_per_minute:
            sleep_until = self.timestamps[0] + 60
            wait_time = sleep_until - now
            if wait_time > 0:
                log.info("Rate limit: sleeping %.1fs (max/min)", wait_time)
                time.sleep(wait_time)
        # Enforce min interval
        if self.timestamps:
            elapsed = now - self.timestamps[-1]
            if elapsed < self.min_interval:
                wait_time = self.min_interval - elapsed
                time.sleep(wait_time)
        self.timestamps.append(time.time())


# ---------------------------------------------------------------------------
# Credentials (1Password + file cache)
# ---------------------------------------------------------------------------

class ResyCredentials:
    """Load and cache credentials from 1Password."""

    OP_REF_PREFIX = "op://OpenClaw/Resy"

    FIELDS = {
        "api_key":    {"ttl": TTL_LONG},
        "email":      {"ttl": TTL_LONG},
        "password":   {"ttl": TTL_LONG},
        "auth_token": {"ttl": TTL_SHORT},
        "payment_id": {"ttl": TTL_SHORT},
    }

    def __init__(self):
        CACHE_DIR.mkdir(parents=True, exist_ok=True)

    def _cache_path(self, name):
        return CACHE_DIR / f"resy_{name}"

    def _read_cache(self, name):
        path = self._cache_path(name)
        if not path.exists():
            return None
        age = time.time() - path.stat().st_mtime
        ttl = self.FIELDS[name]["ttl"]
        if age > ttl:
            return None
        return path.read_text().strip()

    def _write_cache(self, name, value):
        path = self._cache_path(name)
        path.write_text(value)
        path.chmod(0o600)

    def _clear_cache(self, name):
        path = self._cache_path(name)
        if path.exists():
            path.unlink()

    def _op_read(self, field):
        ref = f"{self.OP_REF_PREFIX}/{field}"
        try:
            result = subprocess.run(
                ["timeout", "5", "op", "read", ref],
                capture_output=True, text=True,
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except FileNotFoundError:
            pass
        return None

    def get(self, name):
        """Get a credential by name, using cache then 1Password."""
        cached = self._read_cache(name)
        if cached:
            return cached
        # Only api_key, email, password come from 1Password
        if name in ("api_key", "email", "password"):
            val = self._op_read(name)
            if val:
                self._write_cache(name, val)
                return val
            print(
                f"Error: Could not read '{name}' from 1Password.\n"
                f"Create a 1Password item named 'Resy' in vault 'OpenClaw' "
                f"with fields: email, password, api_key",
                file=sys.stderr,
            )
            sys.exit(1)
        return None

    def set(self, name, value):
        """Cache a credential locally (e.g. auth_token from login)."""
        self._write_cache(name, value)

    def clear(self, name):
        self._clear_cache(name)


# ---------------------------------------------------------------------------
# API Client
# ---------------------------------------------------------------------------

class ResyAPI:
    """Resy API client with auto-refresh and rate limiting."""

    def __init__(self):
        self.creds = ResyCredentials()
        self.limiter = RateLimiter()
        self.session = requests.Session()

    def _headers(self):
        api_key = self.creds.get("api_key")
        headers = {
            "Authorization": f'ResyAPI api_key="{api_key}"',
            "Origin": "https://resy.com",
            "Referer": "https://resy.com/",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144.0.0.0 Safari/537.36",
            "Accept": "application/json, text/plain, */*",
        }
        token = self.creds.get("auth_token")
        if token:
            headers["X-Resy-Auth-Token"] = token
        return headers

    def _ensure_auth(self):
        token = self.creds.get("auth_token")
        if not token:
            self.login()

    def _request(self, method, path, auth_required=True, retry_auth=True, **kwargs):
        if auth_required:
            self._ensure_auth()
        self.limiter.wait()
        url = f"{BASE_URL}{path}"
        headers = self._headers()
        headers.update(kwargs.pop("headers", {}))
        log.info("%s %s", method, path)
        try:
            resp = self.session.request(method, url, headers=headers, timeout=30, **kwargs)
        except requests.RequestException as e:
            log.error("Network error: %s", e)
            # Retry once after 5s
            time.sleep(5)
            try:
                resp = self.session.request(method, url, headers=headers, timeout=30, **kwargs)
            except requests.RequestException as e2:
                log.error("Network error (retry): %s", e2)
                print(f"Error: Network request failed: {e2}", file=sys.stderr)
                sys.exit(1)

        if resp.status_code == 401 and auth_required and retry_auth:
            log.info("Got 401, re-authenticating")
            self.creds.clear("auth_token")
            self.login()
            headers = self._headers()
            return self._request(method, path, auth_required=True, retry_auth=False, headers=headers, **kwargs)

        if resp.status_code == 429:
            # Exponential backoff: 4s, 8s, 16s
            for attempt, delay in enumerate([4, 8, 16], 1):
                log.warning("Rate limited (429), backing off %ds (attempt %d)", delay, attempt)
                time.sleep(delay)
                try:
                    resp = self.session.request(method, url, headers=headers, timeout=30, **kwargs)
                except requests.RequestException:
                    continue
                if resp.status_code != 429:
                    break

        if not resp.ok:
            log.error("API error %d: %s", resp.status_code, _redact(resp.text[:500]))
            try:
                err = resp.json()
                msg = err.get("message", resp.text[:200])
            except Exception:
                msg = resp.text[:200]
            print(f"Error: API returned {resp.status_code}: {msg}", file=sys.stderr)
            sys.exit(1)

        if resp.headers.get("content-type", "").startswith("application/json"):
            return resp.json()
        return resp.text

    def login(self):
        email = self.creds.get("email")
        password = self.creds.get("password")
        data = self._request(
            "POST", "/3/auth/password",
            auth_required=False,
            data={"email": email, "password": password},
        )
        token = data.get("token")
        payment_id = None
        payment_methods = data.get("payment_method_id")
        if payment_methods:
            payment_id = str(payment_methods)
        else:
            # Try extracting from payment_methods list
            pm_list = data.get("payment_methods", [])
            if pm_list:
                payment_id = str(pm_list[0].get("id", ""))

        if not token:
            print("Error: Login failed — no token in response", file=sys.stderr)
            log.error("Login failed: %s", _redact(json.dumps(data)[:500]))
            sys.exit(1)

        self.creds.set("auth_token", token)
        if payment_id:
            self.creds.set("payment_id", payment_id)
        log.info("Authenticated successfully")
        return data

    def search(self, query):
        return self._request("POST", "/3/venuesearch/search", json={
            "query": query,
            "types": ["venue"],
        })

    def find_availability(self, venue_id, day, party_size):
        return self._request("GET", "/4/find", params={
            "venue_id": venue_id,
            "day": day,
            "party_size": party_size,
            "lat": 0,
            "long": 0,
        })

    def get_details(self, config_id, day, party_size):
        return self._request("POST", "/3/details", json={
            "config_id": config_id,
            "day": day,
            "party_size": party_size,
        })

    def book(self, book_token, payment_id):
        # /3/book uses form-encoded, NOT JSON
        return self._request("POST", "/3/book", data={
            "book_token": book_token,
            "struct_payment_method": json.dumps({"id": int(payment_id)}),
            "source_id": "resy.com-venue-details",
        }, headers={"Content-Type": "application/x-www-form-urlencoded"})

    def get_reservations(self):
        return self._request("GET", "/3/user/reservations")

    def cancel(self, resy_token):
        return self._request("POST", "/3/cancel", data={
            "resy_token": resy_token,
        }, headers={"Content-Type": "application/x-www-form-urlencoded"})

    def get_user(self):
        return self._request("GET", "/2/user")


# ---------------------------------------------------------------------------
# Output helpers
# ---------------------------------------------------------------------------

def output(data, human_str=None):
    if JSON_OUTPUT:
        print(json.dumps(data, indent=2, default=str))
    elif human_str:
        print(human_str)
    else:
        print(json.dumps(data, indent=2, default=str))


def fmt_date(date_str):
    """Format a date string for display."""
    if not date_str:
        return "?"
    try:
        dt = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
        return dt.strftime("%a %b %-d, %Y %-I:%M %p")
    except Exception:
        return date_str


# ---------------------------------------------------------------------------
# Command handlers
# ---------------------------------------------------------------------------

def cmd_auth(api):
    data = api.login()
    first = data.get("first_name", "")
    last = data.get("last_name", "")
    output(data, f"Authenticated as {first} {last}")


def cmd_status(api):
    token = api.creds.get("auth_token")
    if not token:
        print("Not authenticated. Run: resy auth")
        return
    user = api.get_user()
    first = user.get("first_name", "")
    last = user.get("last_name", "")
    email = user.get("em_address", "")
    output(user, f"Logged in as: {first} {last} ({email})")


def cmd_search(api, args):
    if not args:
        print("Usage: resy search <query>", file=sys.stderr)
        sys.exit(1)
    query = " ".join(args)
    data = api.search(query)
    if JSON_OUTPUT:
        output(data)
        return
    hits = data.get("search", {}).get("hits", [])
    if not hits:
        print(f"No results for '{query}'")
        return
    total = len(hits)
    hits = hits[:MAX_SEARCH_RESULTS]
    print(f"Results for '{query}' (showing {len(hits)}/{total}):\n")
    for h in hits:
        vid = h.get("id", {}).get("resy", "?")
        name = h.get("name", "?")
        neighborhood = h.get("location", {}).get("neighborhood", "")
        cuisine = ", ".join(h.get("cuisine", []))
        price = h.get("price_range_id", 0)
        price_str = "$" * price if price else ""
        loc_parts = [neighborhood, price_str, cuisine]
        loc = " | ".join(p for p in loc_parts if p)
        print(f"  [{vid}] {name}")
        if loc:
            print(f"        {loc}")


def cmd_availability(api, args):
    if len(args) < 3:
        print("Usage: resy availability <venue_id> <date> <party_size>", file=sys.stderr)
        print("  date format: YYYY-MM-DD", file=sys.stderr)
        sys.exit(1)
    venue_id, day, party_size = args[0], args[1], args[2]
    _validate_date(day)
    _validate_party_size(party_size)
    data = api.find_availability(venue_id, day, party_size)
    if JSON_OUTPUT:
        output(data)
        return
    results = data.get("results", {})
    venues = results.get("venues", [])
    if not venues:
        print(f"No availability for venue {venue_id} on {day} (party of {party_size})")
        return
    venue = venues[0]
    vname = venue.get("venue", {}).get("name", "?")
    slots = venue.get("slots", [])
    print(f"{vname} — {day} — party of {party_size}\n")
    if not slots:
        print("  No available slots")
        return
    total_slots = len(slots)
    slots = slots[:MAX_AVAILABILITY_SLOTS]
    if total_slots > MAX_AVAILABILITY_SLOTS:
        print(f"  Showing {MAX_AVAILABILITY_SLOTS}/{total_slots} slots\n")
    for slot in slots:
        config = slot.get("config", {})
        token = config.get("token", "?")
        slot_type = config.get("type", "?")
        date_info = slot.get("date", {})
        start = date_info.get("start", "?")
        end = date_info.get("end", "?")
        # Extract just the time portion
        start_time = start.split(" ")[-1] if " " in start else start
        end_time = end.split(" ")[-1] if " " in end else end
        payment = slot.get("payment", {})
        price = ""
        if payment:
            amt = payment.get("cancellation_fee")
            if amt:
                price = f" (cancel fee: ${amt})"
        print(f"  {start_time}-{end_time}  {slot_type:12s}  token: {token}{price}")


def cmd_book(api, args):
    if len(args) < 3:
        print("Usage: resy book <config_token> <date> <party_size>", file=sys.stderr)
        sys.exit(1)
    config_token, day, party_size = args[0], args[1], args[2]
    _validate_date(day)
    _validate_party_size(party_size)

    # Get booking details
    details = api.get_details(config_token, day, int(party_size))
    book_token = details.get("book_token", {}).get("value")
    if not book_token:
        print("Error: Could not get book token from details", file=sys.stderr)
        sys.exit(1)

    # Display summary
    venue_name = details.get("venue", {}).get("name", "?")
    config = details.get("config", {})
    slot_type = config.get("type", "?")
    date_info = details.get("config", {}).get("date", {})
    start = date_info.get("start", "?")

    print(f"Booking Summary:")
    print(f"  Restaurant: {venue_name}")
    print(f"  Date:       {day}")
    print(f"  Time:       {start}")
    print(f"  Type:       {slot_type}")
    print(f"  Party:      {party_size}")

    if DRY_RUN:
        print("\n[DRY RUN] Would book — stopping before confirmation.")
        if JSON_OUTPUT:
            output(details)
        return

    confirm = input("\nBook this reservation? (yes/no): ").strip().lower()
    if confirm != "yes":
        print("Booking cancelled.")
        return

    payment_id = api.creds.get("payment_id")
    if not payment_id:
        print("Error: No payment method found. Run 'resy auth' first.", file=sys.stderr)
        sys.exit(1)

    result = api.book(book_token, payment_id)
    output(result, "Reservation booked successfully!")


def cmd_cancel(api, args):
    if not args:
        print("Usage: resy cancel <resy_token>", file=sys.stderr)
        sys.exit(1)
    resy_token = args[0]

    print(f"Cancel reservation token: {resy_token}")

    if DRY_RUN:
        print("\n[DRY RUN] Would cancel — stopping.")
        return

    confirm = input("\nCancel this reservation? (yes/no): ").strip().lower()
    if confirm != "yes":
        print("Cancellation aborted.")
        return

    result = api.cancel(resy_token)
    output(result, "Reservation cancelled.")


def cmd_reservations(api):
    data = api.get_reservations()
    if JSON_OUTPUT:
        output(data)
        return
    reservations = data if isinstance(data, list) else data.get("reservations", [])
    if not reservations:
        print("No upcoming reservations.")
        return
    # Separate upcoming from past
    today = datetime.now().strftime("%Y-%m-%d")
    upcoming = [r for r in reservations if r.get("day", "") >= today]
    past = [r for r in reservations if r.get("day", "") < today]

    def _print_reservation(r):
        venue_id = r.get("venue", {}).get("id", "?")
        day = r.get("day", "?")
        time_slot = r.get("time_slot", "?")
        # Strip seconds from time_slot (19:30:00 → 19:30)
        if isinstance(time_slot, str) and time_slot.count(":") == 2:
            time_slot = time_slot[:5]
        num_seats = r.get("num_seats", "?")
        config_type = r.get("config", {}).get("type", "")
        resy_token = r.get("resy_token", "?")
        cancel_info = r.get("cancellation", {})
        can_cancel = cancel_info.get("allowed", False)
        status = r.get("status", {})
        finished = status.get("finished", 0) if isinstance(status, dict) else 0

        label = f"Venue {venue_id}"
        if config_type:
            label += f" ({config_type})"
        print(f"  {label}")
        print(f"    Date:  {day} at {time_slot}")
        print(f"    Party: {num_seats}")
        print(f"    Token: {resy_token}")
        if can_cancel:
            fee = cancel_info.get("fee", {}).get("amount", 0)
            if fee:
                print(f"    Cancel: allowed (fee: ${fee})")
            else:
                print(f"    Cancel: allowed (no fee)")
        if finished:
            print(f"    Status: completed")
        print()

    if upcoming:
        print(f"Upcoming Reservations ({len(upcoming)}):\n")
        for r in upcoming:
            _print_reservation(r)
    else:
        print("No upcoming reservations.\n")
    if past:
        print(f"Past Reservations ({len(past)}):\n")
        for r in past[:5]:  # Show only last 5
            _print_reservation(r)
        if len(past) > 5:
            print(f"  ... and {len(past) - 5} more")


def cmd_snipe(api, args):
    if len(args) < 3:
        print("Usage: resy snipe <venue_id> <date> <party_size> [--time HH:MM] [--duration SECS] [--confirm]", file=sys.stderr)
        sys.exit(1)

    venue_id = args[0]
    day = args[1]
    party_size = args[2]
    _validate_date(day)
    _validate_party_size(party_size)

    # Parse optional flags
    target_time = None
    duration = 1800  # 30 minutes default
    auto_confirm = False
    i = 3
    while i < len(args):
        if args[i] == "--time" and i + 1 < len(args):
            target_time = args[i + 1]
            i += 2
        elif args[i] == "--duration" and i + 1 < len(args):
            duration = int(args[i + 1])
            i += 2
        elif args[i] == "--confirm":
            auto_confirm = True
            i += 1
        else:
            i += 1

    print(f"Snipe Mode:")
    print(f"  Venue:    {venue_id}")
    print(f"  Date:     {day}")
    print(f"  Party:    {party_size}")
    if target_time:
        print(f"  Target:   {target_time} (±30 min)")
    print(f"  Duration: {duration}s")
    if not auto_confirm:
        print(f"\n  [DRY RUN] Will poll but NOT book (add --confirm to auto-book)")
    print(f"\nPolling every 30s... (Ctrl+C to stop)\n")

    start_time = time.time()
    poll_count = 0

    try:
        while True:
            elapsed = time.time() - start_time
            if elapsed > duration:
                print(f"\nNo matching slots found in {duration}s. Stopping.")
                return

            poll_count += 1
            log.info("Snipe poll #%d for venue %s on %s", poll_count, venue_id, day)

            try:
                data = api.find_availability(venue_id, day, party_size)
            except SystemExit:
                # API error — continue polling
                log.warning("API error during snipe poll, continuing")
                time.sleep(30)
                continue

            results = data.get("results", {})
            venues = results.get("venues", [])
            if not venues:
                _snipe_status(poll_count, elapsed, duration)
                time.sleep(30)
                continue

            slots = venues[0].get("slots", [])
            if not slots:
                _snipe_status(poll_count, elapsed, duration)
                time.sleep(30)
                continue

            # Filter by time if specified
            matching = slots
            if target_time:
                matching = _filter_by_time(slots, target_time)

            if not matching:
                _snipe_status(poll_count, elapsed, duration)
                time.sleep(30)
                continue

            # Found a match
            slot = matching[0]
            config = slot.get("config", {})
            token = config.get("token")
            date_info = slot.get("date", {})
            start = date_info.get("start", "?")
            slot_type = config.get("type", "?")

            print(f"\n  MATCH FOUND: {start} ({slot_type})")

            if not auto_confirm:
                print(f"  [DRY RUN] Would book token: {token}")
                print(f"  Run with --confirm to auto-book")
                return

            # Auto-book
            try:
                details = api.get_details(token, day, int(party_size))
                book_token = details.get("book_token", {}).get("value")
                if not book_token:
                    print("  Error: Could not get book token", file=sys.stderr)
                    return
                payment_id = api.creds.get("payment_id")
                if not payment_id:
                    print("  Error: No payment method", file=sys.stderr)
                    return
                result = api.book(book_token, payment_id)
                print(f"  BOOKED successfully!")
                if JSON_OUTPUT:
                    output(result)
            except SystemExit:
                print("  Error during booking", file=sys.stderr)
            return

    except KeyboardInterrupt:
        print(f"\n\nStopped after {poll_count} polls ({int(time.time() - start_time)}s)")


def _snipe_status(poll_count, elapsed, duration):
    remaining = int(duration - elapsed)
    print(f"  Poll #{poll_count}: no match ({remaining}s remaining)", end="\r")
    sys.stdout.flush()


def _filter_by_time(slots, target_time):
    """Filter slots within ±30 minutes of target time."""
    try:
        target_h, target_m = map(int, target_time.split(":"))
        target_minutes = target_h * 60 + target_m
    except ValueError:
        return slots

    matched = []
    for slot in slots:
        start = slot.get("date", {}).get("start", "")
        # Extract time from "YYYY-MM-DD HH:MM:SS" or "HH:MM"
        time_part = start.split(" ")[-1] if " " in start else start
        try:
            parts = time_part.split(":")
            slot_minutes = int(parts[0]) * 60 + int(parts[1])
            if abs(slot_minutes - target_minutes) <= 30:
                matched.append(slot)
        except (ValueError, IndexError):
            continue
    return matched


def cmd_help():
    print("""Usage: resy <command> [args] [--json] [--dry-run]

Commands:
  auth                                     Login and cache token
  status                                   Show auth status + account info
  search <query>                           Search restaurants by name
  availability <venue_id> <date> <party>   Check available slots
  book <config_token> <date> <party>       Book a reservation
  cancel <resy_token>                      Cancel a reservation
  reservations                             List upcoming reservations
  snipe <venue_id> <date> <party> [opts]   Auto-book when slot appears
  help                                     Show this help

Snipe options:
  --time HH:MM       Target time (matches ±30 min window)
  --duration SECS    How long to poll (default: 1800 = 30 min)
  --confirm          Actually book (without this, dry-run only)

Global flags:
  --json             Output raw JSON
  --dry-run          Stop before booking/cancelling""")


# ---------------------------------------------------------------------------
# Validators
# ---------------------------------------------------------------------------

def _validate_date(day):
    try:
        datetime.strptime(day, "%Y-%m-%d")
    except ValueError:
        print(f"Error: Invalid date '{day}'. Use YYYY-MM-DD format.", file=sys.stderr)
        sys.exit(1)
    d = datetime.strptime(day, "%Y-%m-%d").date()
    if d < datetime.now().date():
        print(f"Error: Date '{day}' is in the past.", file=sys.stderr)
        sys.exit(1)


def _validate_party_size(ps):
    try:
        n = int(ps)
        if n < 1 or n > 20:
            raise ValueError
    except ValueError:
        print(f"Error: Invalid party size '{ps}'. Must be 1-20.", file=sys.stderr)
        sys.exit(1)


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    global JSON_OUTPUT, DRY_RUN

    args = sys.argv[1:]

    # Extract global flags
    if "--json" in args:
        JSON_OUTPUT = True
        args.remove("--json")
    if "--dry-run" in args:
        DRY_RUN = True
        args.remove("--dry-run")

    if not args or args[0] in ("help", "--help", "-h"):
        cmd_help()
        return

    command = args[0]
    rest = args[1:]
    api = ResyAPI()

    if command == "auth":
        cmd_auth(api)
    elif command == "status":
        cmd_status(api)
    elif command == "search":
        cmd_search(api, rest)
    elif command == "availability":
        cmd_availability(api, rest)
    elif command == "book":
        cmd_book(api, rest)
    elif command == "cancel":
        cmd_cancel(api, rest)
    elif command == "reservations":
        cmd_reservations(api)
    elif command == "snipe":
        cmd_snipe(api, rest)
    else:
        print(f"Unknown command: {command}. Run 'resy help'.", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
