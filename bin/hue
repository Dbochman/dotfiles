#!/bin/bash
# hue — CLI wrapper for Philips Hue Bridge REST API
# Supports local (LAN) and remote (cloud) access. Tries local first, falls back to remote.
# Credentials stored in 1Password + local cache files.

set -euo pipefail

export OP_BIOMETRIC_UNLOCK_ENABLED=true

# 1Password paths — bridge selection via HUE_BRIDGE env or --bridge flag
OP_VAULT="Private"
_BRIDGE_NAME="${HUE_BRIDGE:-crosstown}"

# Parse --bridge flag from args (strip it before dispatch)
_ORIG_ARGS=("$@")
_CLEAN_ARGS=()
for _arg in "$@"; do
  case "$_arg" in
    --bridge=*) _BRIDGE_NAME="${_arg#--bridge=}" ;;
    --cabin)    _BRIDGE_NAME="cabin" ;;
    --crosstown) _BRIDGE_NAME="crosstown" ;;
    *)          _CLEAN_ARGS+=("$_arg") ;;
  esac
done
set -- "${_CLEAN_ARGS[@]+"${_CLEAN_ARGS[@]}"}"

case "$(echo "$_BRIDGE_NAME" | tr '[:upper:]' '[:lower:]')" in
  cabin|cab)     OP_ITEM="Philips Hue Bridge - Cabin" ;;
  crosstown|ct)  OP_ITEM="Philips Hue Bridge - Crosstown" ;;
  *)             OP_ITEM="Philips Hue Bridge - $_BRIDGE_NAME" ;;
esac

# Cache credentials — per-bridge subdirectory
CACHE_DIR="${HOME}/.cache/hue/$(echo "$_BRIDGE_NAME" | tr '[:upper:]' '[:lower:]')"
CACHE_TTL=31536000       # 1 year for static creds
TOKEN_TTL=604800         # 7 days for access tokens (actual expiry)
TOKEN_REFRESH_AT=518400  # Refresh after 6 days (proactive)

# Remote API base
REMOTE_API="https://api.meethue.com/route"

# Connection mode: auto (try local, fall back to remote), local, remote
HUE_MODE="${HUE_MODE:-auto}"

_op_read() {
  /opt/homebrew/bin/op item get "$OP_ITEM" --vault "$OP_VAULT" --fields label="$1" --reveal 2>/dev/null
}

_cached_read() {
  local label="$1" ttl="${2:-$CACHE_TTL}"
  local cache_file="$CACHE_DIR/$(echo "$label" | tr ' ' '_' | tr '[:upper:]' '[:lower:]')"
  mkdir -p "$CACHE_DIR"

  if [[ -f "$cache_file" ]]; then
    local age=$(( $(date +%s) - $(stat -f %m "$cache_file") ))
    if (( age < ttl )); then
      cat "$cache_file"
      return
    fi
  fi

  local val
  val=$(_op_read "$label")
  if [[ -n "$val" ]]; then
    echo "$val" > "$cache_file"
  fi
  echo "$val"
}

# --- Local API ---

_HUE_BRIDGE=""
_HUE_KEY=""

_get_local_creds() {
  if [[ -n "$_HUE_BRIDGE" && -n "$_HUE_KEY" ]]; then return; fi
  _HUE_BRIDGE=$(_cached_read "Bridge IP")
  _HUE_KEY=$(_cached_read "API Key")
}

_local_reachable() {
  _get_local_creds
  [[ -n "$_HUE_BRIDGE" ]] && curl -s --connect-timeout 2 --max-time 3 "http://${_HUE_BRIDGE}/api/${_HUE_KEY}/config" >/dev/null 2>&1
}

# --- Remote API ---

_REMOTE_TOKEN=""
_REMOTE_USERNAME=""

_get_remote_creds() {
  if [[ -n "$_REMOTE_TOKEN" && -n "$_REMOTE_USERNAME" ]]; then return; fi
  _REMOTE_USERNAME=$(_cached_read "Remote_Username")
  _REMOTE_TOKEN=$(_cached_read "Remote_Access_Token" "$TOKEN_REFRESH_AT")

  # If token cache expired, refresh it
  if [[ -z "$_REMOTE_TOKEN" ]]; then
    _refresh_remote_token
  fi
}

_refresh_remote_token() {
  local client_id client_secret refresh_token
  client_id=$(_cached_read "Remote_ClientId")
  client_secret=$(_cached_read "Remote_Client_Secret")
  refresh_token=$(_cached_read "Remote_Refresh_Token" "$CACHE_TTL")

  if [[ -z "$client_id" || -z "$client_secret" || -z "$refresh_token" ]]; then
    echo "Error: Missing remote API credentials. Run OAuth setup first." >&2
    return 1
  fi

  local resp
  resp=$(curl -s -X POST "https://api.meethue.com/v2/oauth2/token" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -u "${client_id}:${client_secret}" \
    -d "grant_type=refresh_token&refresh_token=${refresh_token}")

  local new_token new_refresh
  new_token=$(echo "$resp" | python3 -c "import sys,json; print(json.load(sys.stdin).get('access_token',''))" 2>/dev/null)
  new_refresh=$(echo "$resp" | python3 -c "import sys,json; print(json.load(sys.stdin).get('refresh_token',''))" 2>/dev/null)

  if [[ -z "$new_token" ]]; then
    echo "Error: Failed to refresh remote token: $resp" >&2
    return 1
  fi

  mkdir -p "$CACHE_DIR"
  echo "$new_token" > "$CACHE_DIR/remote_access_token"
  _REMOTE_TOKEN="$new_token"

  if [[ -n "$new_refresh" ]]; then
    echo "$new_refresh" > "$CACHE_DIR/remote_refresh_token"
  fi

  echo "Remote token refreshed" >&2
}

# --- Unified API layer ---

_USE_REMOTE=""

_resolve_mode() {
  if [[ -n "$_USE_REMOTE" ]]; then return; fi

  case "$HUE_MODE" in
    local)
      _USE_REMOTE=false
      ;;
    remote)
      _USE_REMOTE=true
      ;;
    auto)
      if _local_reachable; then
        _USE_REMOTE=false
      else
        _USE_REMOTE=true
      fi
      ;;
  esac
}

_api_get() {
  _resolve_mode
  if [[ "$_USE_REMOTE" == "true" ]]; then
    _get_remote_creds
    curl -s "${REMOTE_API}/api/${_REMOTE_USERNAME}${1}" \
      -H "Authorization: Bearer ${_REMOTE_TOKEN}"
  else
    _get_local_creds
    curl -s "http://${_HUE_BRIDGE}/api/${_HUE_KEY}${1}"
  fi
}

_api_put() {
  _resolve_mode
  if [[ "$_USE_REMOTE" == "true" ]]; then
    _get_remote_creds
    curl -s -X PUT "${REMOTE_API}/api/${_REMOTE_USERNAME}${1}" \
      -H "Authorization: Bearer ${_REMOTE_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "$2"
  else
    _get_local_creds
    curl -s -X PUT "http://${_HUE_BRIDGE}/api/${_HUE_KEY}${1}" -d "$2"
  fi
}

# === Room/Group resolution ===

_group_map=""
_build_group_map() {
  [[ -n "$_group_map" ]] && return
  _group_map=$(_api_get /groups | python3 -c "
import sys, json
data = json.load(sys.stdin)
for gid, g in data.items():
    if g.get('type') == 'Room':
        print(f\"{g['name']}\t{gid}\")
")
}

_resolve_group() {
  local query
  query="$(echo "$1" | tr '[:upper:]' '[:lower:]')"
  _build_group_map
  local match
  match=$(echo "$_group_map" | awk -F'\t' -v q="$query" 'tolower($1) ~ q {print $2; exit}')
  if [[ -z "$match" ]]; then
    echo "No room matching '$1'. Available:" >&2
    echo "$_group_map" | awk -F'\t' '{print "  - " $1}' >&2
    exit 1
  fi
  echo "$match"
}

_resolve_light() {
  local query
  query="$(echo "$1" | tr '[:upper:]' '[:lower:]')"
  local data
  data=$(_api_get /lights)
  local match
  match=$(echo "$data" | python3 -c "
import sys, json
data = json.load(sys.stdin)
q = '${query}'
for lid, l in data.items():
    if q in l['name'].lower():
        print(lid)
        break
" 2>/dev/null)
  if [[ -z "$match" ]]; then
    echo "No light matching '$1'." >&2
    exit 1
  fi
  echo "$match"
}

# === Commands ===

cmd_status() {
  local filter="${1:-}"
  local data
  data=$(_api_get /groups)
  python3 -c "
import sys, json
data = json.load(sys.stdin)
filt = '${filter}'.lower()
for gid, g in sorted(data.items(), key=lambda x: int(x[0])):
    if g.get('type') != 'Room':
        continue
    name = g['name']
    if filt and filt not in name.lower():
        continue
    action = g.get('action', {})
    on = g.get('state', {}).get('any_on', False)
    bri = action.get('bri', 0)
    pct = round(bri / 254 * 100)
    ct = action.get('ct')
    n_lights = len(g.get('lights', []))
    status = 'ON' if on else 'OFF'
    ct_str = f'{ct} mired' if ct else ''
    print(f'{name:20s}  {status:3s}  {pct:3d}%  {n_lights} lights  {ct_str}')
" <<< "$data"
}

cmd_on() {
  local target="$1"
  shift
  local bri_arg=""
  if [[ $# -gt 0 ]]; then
    local pct="$1"
    local bri=$(python3 -c "print(round(${pct} / 100 * 254))")
    bri_arg=", \"bri\": ${bri}"
  fi
  local gid
  gid=$(_resolve_group "$target")
  _api_put "/groups/${gid}/action" "{\"on\": true${bri_arg}}" > /dev/null
  echo "Turned on $target"
}

cmd_off() {
  local target="$1"
  local gid
  gid=$(_resolve_group "$target")
  _api_put "/groups/${gid}/action" "{\"on\": false}" > /dev/null
  echo "Turned off $target"
}

cmd_brightness() {
  local target="$1" pct="$2"
  local bri
  bri=$(python3 -c "print(round(${pct} / 100 * 254))")
  local gid
  gid=$(_resolve_group "$target")
  _api_put "/groups/${gid}/action" "{\"on\": true, \"bri\": ${bri}}" > /dev/null
  echo "Set $target to ${pct}%"
}

cmd_color() {
  local target="$1" color="$2"
  local gid
  gid=$(_resolve_group "$target")

  # Map common color names to hue/sat values
  local payload color_lower
  color_lower="$(echo "$color" | tr '[:upper:]' '[:lower:]')"
  case "$color_lower" in
    red)        payload='{"on":true,"hue":0,"sat":254}' ;;
    orange)     payload='{"on":true,"hue":5000,"sat":254}' ;;
    yellow)     payload='{"on":true,"hue":10000,"sat":254}' ;;
    green)      payload='{"on":true,"hue":21845,"sat":254}' ;;
    blue)       payload='{"on":true,"hue":43690,"sat":254}' ;;
    purple)     payload='{"on":true,"hue":50000,"sat":254}' ;;
    pink)       payload='{"on":true,"hue":56000,"sat":200}' ;;
    warm|warm-white)  payload='{"on":true,"ct":400}' ;;
    cool|cool-white)  payload='{"on":true,"ct":200}' ;;
    daylight)   payload='{"on":true,"ct":153}' ;;
    *)
      # Try as mired color temperature (number)
      if [[ "$color" =~ ^[0-9]+$ ]]; then
        payload="{\"on\":true,\"ct\":${color}}"
      else
        echo "Unknown color: $color. Use: red, orange, yellow, green, blue, purple, pink, warm, cool, daylight, or a mired value (153-500)." >&2
        exit 1
      fi
      ;;
  esac

  _api_put "/groups/${gid}/action" "$payload" > /dev/null
  echo "Set $target to $color"
}

cmd_scene() {
  local target="$1" scene_query
  scene_query="$(echo "$2" | tr '[:upper:]' '[:lower:]')"
  local gid
  gid=$(_resolve_group "$target")

  local scenes
  scenes=$(_api_get /scenes)
  local scene_id
  scene_id=$(echo "$scenes" | python3 -c "
import sys, json
data = json.load(sys.stdin)
q = '${scene_query}'
gid = '${gid}'
for sid, s in data.items():
    if q in s['name'].lower() and s.get('group') == gid:
        print(sid)
        break
" 2>/dev/null)

  if [[ -z "$scene_id" ]]; then
    echo "No scene matching '$2' in $target. Available scenes:" >&2
    echo "$scenes" | python3 -c "
import sys, json
data = json.load(sys.stdin)
gid = '${gid}'
for sid, s in data.items():
    if s.get('group') == gid:
        print(f\"  - {s['name']}\")
" >&2
    exit 1
  fi

  _api_put "/groups/${gid}/action" "{\"scene\": \"${scene_id}\"}" > /dev/null
  echo "Activated scene '$2' in $target"
}

cmd_all_on() {
  _api_put "/groups/0/action" '{"on": true}' > /dev/null
  echo "All lights on"
}

cmd_all_off() {
  _api_put "/groups/0/action" '{"on": false}' > /dev/null
  echo "All lights off"
}

cmd_lights() {
  local filter="${1:-}"
  _api_get /lights | python3 -c "
import sys, json
data = json.load(sys.stdin)
filt = '${filter}'.lower()
for lid, l in sorted(data.items(), key=lambda x: int(x[0])):
    name = l['name']
    if filt and filt not in name.lower():
        continue
    s = l['state']
    on = 'ON' if s.get('on') else 'OFF'
    bri = s.get('bri', 0)
    pct = round(bri / 254 * 100)
    reach = 'ok' if s.get('reachable') else 'UNREACHABLE'
    print(f'  {lid:>3}  {name:30s}  {on:3s}  {pct:3d}%  {reach}')
"
}

cmd_raw() {
  local endpoint="${1:-/lights}"
  _api_get "$endpoint" | python3 -m json.tool
}

cmd_help() {
  cat <<'HELP'
Usage: hue <command> [args]

Commands:
  status [room]                Show all rooms (or one room)
  on <room> [brightness%]      Turn on a room (optional brightness 0-100)
  off <room>                   Turn off a room
  bri <room> <percent>         Set brightness (0-100)
  color <room> <color>         Set color (red, blue, warm, cool, daylight, etc.)
  scene <room> <scene>         Activate a scene
  all-on                       Turn on all lights
  all-off                      Turn off all lights
  lights [filter]              List individual lights
  raw [endpoint]               Raw JSON dump (default: /lights)
  help                         Show this help

Room names are fuzzy-matched (e.g. "bed" matches "Bedroom").

Bridges: --crosstown (default), --cabin, or HUE_BRIDGE=cabin
Connection: tries local LAN first, falls back to Hue Cloud API.
Override with HUE_MODE=local or HUE_MODE=remote.
HELP
}

case "${1:-help}" in
  status)     cmd_status "${2:-}" ;;
  on)         cmd_on "${2:?room required}" "${@:3}" ;;
  off)        cmd_off "${2:?room required}" ;;
  bri|brightness) cmd_brightness "${2:?room required}" "${3:?percent required}" ;;
  color)      cmd_color "${2:?room required}" "${3:?color required}" ;;
  scene)      cmd_scene "${2:?room required}" "${3:?scene required}" ;;
  all-on)     cmd_all_on ;;
  all-off)    cmd_all_off ;;
  lights)     cmd_lights "${2:-}" ;;
  raw)        cmd_raw "${2:-/lights}" ;;
  help|--help|-h) cmd_help ;;
  *)          echo "Unknown command: $1. Run 'hue help'." >&2; exit 1 ;;
esac
